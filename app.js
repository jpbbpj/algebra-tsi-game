
// Algebra Quest â€” Final SPA (compact)
function setVh(){document.documentElement.style.setProperty('--vh', window.innerHeight*0.01+'px');}
setVh(); window.addEventListener('resize', setVh);
function randInt(min,max){return Math.floor(Math.random()*(max-min+1))+min}
function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]]}return a}
const LS_KEY='algebra_quest_state_v2'; let STATE={settings:{selectedLevel:1,problemsPerRound:100,enableSound:true,verboseSteps:false},progress:{xp:0,unlocked:[1],scores:{}},pools:{}}; try{const s=JSON.parse(localStorage.getItem(LS_KEY)||'null'); if(s) STATE=s}catch(e){console.warn(e)}
function save(){localStorage.setItem(LS_KEY,JSON.stringify(STATE))}
const el=id=>document.getElementById(id);
const levelButtons=el('levelButtons'), startAtLevelBtn=el('startAtLevelBtn'), problemsPerRoundInput=el('problemsPerRound'), enableSoundInput=el('enableSound'), verboseToggle=el('verboseToggle'), scoreEl=el('score'), levelInfo=el('levelInfo'), progressFill=el('progressFill'), progressText=el('progressText'), questionText=el('questionText'), answerInput=el('answerInput'), submitBtn=el('submitBtn'), stepsBtn=el('stepsBtn'), feedback=el('feedback'), stepsModal=el('stepsModal'), stepsList=el('stepsList'), closeStepsBtn=el('closeStepsBtn'), advanceBtn=el('advanceBtn'), retryBtn=el('retryBtn'), homeBtn=el('homeBtn'), endSummary=el('endSummary'), celebration=el('celebration');
function playTone(f,t='sine',d=0.12){ if(!STATE.settings.enableSound) return; try{ const C=new (window.AudioContext||window.webkitAudioContext)(); const o=C.createOscillator(); const g=C.createGain(); o.type=t; o.frequency.value=f; o.connect(g); g.connect(C.destination); g.gain.value=0.0001; const now=C.currentTime; g.gain.exponentialRampToValueAtTime(0.12,now+0.01); o.start(now); g.gain.exponentialRampToValueAtTime(0.0001,now+d); o.stop(now+d+0.02);}catch(e){} }
function playSuccess(){playTone(880)} function playFail(){playTone(220,'sawtooth',0.18)} function playLevelUp(){playTone(1200,'triangle',0.28); playTone(1600,'sine',0.18)}
const LEVEL_SPEC = {1:{name:'Addition',gen:()=>{const a=randInt(1,9),b=randInt(1,9);return {prompt:`${a} + ${b}`,answer:(a+b).toString(),type:'arithmetic'}}},2:{name:'Subtraction',gen:()=>{const a=randInt(5,20),b=randInt(1,9);return {prompt:`${a} - ${b}`,answer:(a-b).toString(),type:'arithmetic'}}},3:{name:'Multiplication',gen:()=>{const a=randInt(2,12),b=randInt(2,12);return {prompt:`${a} Ã— ${b}`,answer:(a*b).toString(),type:'arithmetic'}}},4:{name:'Mixed Ops',gen:()=>{const a=randInt(1,8),b=randInt(1,8),c=randInt(1,8);return {prompt:`${a} Ã— (${b} + ${c})`,answer:(a*(b+c)).toString(),type:'arithmetic'}}},5:{name:'One-step eq',gen:()=>{const a=randInt(1,10),x=randInt(1,10),b=a+x;return {prompt:`x + ${a} = ${b}`,answer:x.toString(),type:'linear'}}},6:{name:'Two-step eq',gen:()=>{const a=randInt(2,6),x=randInt(1,10),b=randInt(0,10),c=a*x+b;return {prompt:`${a}x + ${b} = ${c}`,answer:x.toString(),type:'linear'}}},7:{name:'Distribution',gen:()=>{const a=randInt(1,6),b=randInt(1,6),c=randInt(1,6),x=randInt(1,6);return {prompt:`${a}(${b}x + ${c}) = ${a*b*x + a*c}`,answer:x.toString(),type:'linear'}}},8:{name:'Fractions',gen:()=>{const denom=randInt(2,6),num=randInt(1,9),x=randInt(1,10),b=randInt(1,6);const c=(num/denom)*x + b;return {prompt:`${num}/${denom}x + ${b} = ${c}`,answer:x.toString(),type:'linear'}}},9:{name:'Inequalities',gen:()=>{const a=randInt(1,6),x=randInt(1,8),b=randInt(0,10),c=a*x+b;return {prompt:`${a}x + ${b} < ${c+randInt(1,3)}`,answer:x.toString(),type:'inequality'}}},10:{name:'Word problems',gen:()=>{const x=randInt(1,8),y=randInt(1,8),s=x+y,d=x-y;return {prompt:`Two numbers sum to ${s} and differ by ${d}. Find first number.`,answer:x.toString(),type:'word'}}}}
function ensurePool(level){ if(STATE.pools[level] && STATE.pools[level].length>=100) return; STATE.pools[level]=[]; const seen=new Set(); while(STATE.pools[level].length<100){ const p=LEVEL_SPEC[level].gen(); const k=JSON.stringify(p); if(!seen.has(k)){seen.add(k); STATE.pools[level].push(p);} } save(); }
for(let i=1;i<=10;i++) ensurePool(i);
function solveProblem(problem,verbose){ const steps=[]; const t=problem.type; if(t==='arithmetic'){ if(problem.prompt.includes('Ã—')){ const [a,b]=problem.prompt.replace('Ã—','*').split('*').map(s=>s.trim()); steps.push(`Start with: ${a} Ã— ${b}`); steps.push(`Multiply: ${a} Ã— ${b} = ${Number(a)*Number(b)}`); return steps;} if(problem.prompt.includes('+')){ const [a,b]=problem.prompt.split('+').map(s=>s.trim()); steps.push(`Start with: ${a} + ${b}`); steps.push(`Add: ${a} + ${b} = ${Number(a)+Number(b)}`); return steps;} if(problem.prompt.includes('-')){ const [a,b]=problem.prompt.split('-').map(s=>s.trim()); steps.push(`Start with: ${a} - ${b}`); steps.push(`Subtract: ${a} - ${b} = ${Number(a)-Number(b)}`); return steps;} steps.push('Compute step-by-step using arithmetic.'); return steps;} if(t==='linear'){ const s=problem.prompt.replace(/\s+/g,''); const m=s.match(/^([+-]?\d*)x([+-]?\d*)=([+-]?\d+)$/); if(m){ const a=m[1]===''?1:(m[1]==='-'?-1:Number(m[1])); const b=m[2]===''?0:Number(m[2]); const c=Number(m[3]); steps.push(`Start with: ${a}x ${b>=0?'+':''}${b} = ${c}`); steps.push(`Subtract ${b} from both sides: ${a}x = ${c - b}`); steps.push(`Divide both sides by ${a}: x = ${(c - b)/a}`); return steps;} const m2=problem.prompt.match(/^x\+?(\d*)=(\d*)$/); if(m2){ const a=Number(m2[1]), b=Number(m2[2]); steps.push(`Start with: x + ${a} = ${b}`); steps.push(`Subtract ${a} from both sides: x = ${b} - ${a}`); steps.push(`Compute: x = ${b - a}`); return steps;} steps.push('Isolate x by moving constants and dividing by coefficients.'); return steps;} if(t==='inequality'){ steps.push('Isolate the variable. Remember to flip inequality when multiplying/dividing by negative.'); return steps;} if(t==='word'){ steps.push('Translate the words into equations, assign variables, then solve step-by-step.'); return steps;} return ['No steps available.']; }
function showScreen(id){ document.querySelectorAll('.screen').forEach(s=>s.classList.remove('active')); document.getElementById(id).classList.add('active'); if(id==='game') setTimeout(()=>answerInput.focus(),300); }
function updateLevelButtons(){ levelButtons.innerHTML=''; for(let i=1;i<=10;i++){ const btn=document.createElement('button'); btn.textContent=i; btn.className='level-button'; if(!STATE.progress.unlocked.includes(i)) btn.classList.add('locked'); btn.dataset.level=i; btn.onclick=()=>{ STATE.settings.selectedLevel=i; document.querySelectorAll('.level-button').forEach(b=>b.classList.remove('active')); btn.classList.add('active'); save(); }; if(Number(STATE.settings.selectedLevel)===i) btn.classList.add('active'); levelButtons.appendChild(btn);} }
updateLevelButtons();
let runtime={level:STATE.settings.selectedLevel,index:0,correct:0,total:STATE.settings.problemsPerRound||100};
function loadLevel(level){ runtime.level=level; runtime.index=0; runtime.correct=0; runtime.total=Math.min(STATE.pools[level].length, Number(STATE.settings.problemsPerRound)||100); levelInfo.textContent=`Level ${level}: ${LEVEL_SPEC[level].name}`; updateProgress(); showScreen('game'); showProblem(); }
function showProblem(){ const p=STATE.pools[runtime.level][runtime.index]; questionText.textContent=p.prompt; answerInput.value=''; feedback.textContent=''; updateProgress(); }
function updateProgress(){ const total=runtime.total||1; const filled=Math.round((runtime.index/total)*100); progressFill.style.width=filled+'%'; progressText.textContent=`${Math.min(runtime.index+1,total)} / ${total}`; scoreEl.textContent=`XP: ${STATE.progress.xp||0}`; }
function showSteps(problem){ const steps=solveProblem(problem, STATE.settings.verboseSteps||verboseToggle.checked); stepsList.innerHTML=''; steps.forEach(s=>{const li=document.createElement('li'); li.textContent=s; stepsList.appendChild(li);}); stepsModal.setAttribute('aria-hidden','false'); }
el('closeStepsBtn').onclick=()=>stepsModal.setAttribute('aria-hidden','true'); stepsBtn.onclick=()=>{ const p=STATE.pools[runtime.level][runtime.index]; showSteps(p); }
function checkAnswer(){ const p=STATE.pools[runtime.level][runtime.index]; const user=answerInput.value.trim(); let correct=false; if(Array.isArray(p.answer)) correct=p.answer.map(String).includes(user); else correct=String(p.answer)===user || (Number(user) && Math.abs(Number(user)-Number(p.answer))<0.01); if(correct){ runtime.correct+=1; feedback.textContent='âœ… Correct!'; playSuccess(); } else { feedback.textContent=`âŒ Incorrect â€” Answer: ${Array.isArray(p.answer)?p.answer.join(', '):p.answer}`; playFail(); } runtime.index+=1; updateProgress(); setTimeout(()=>{ if(runtime.index>=runtime.total){ endLevel(); } else showProblem(); },700); }
function endLevel(){ const correct=runtime.correct; const total=runtime.total; const pct=Math.round((correct/total)*100); STATE.progress.scores[runtime.level]={correct,total,pct}; STATE.progress.xp=(STATE.progress.xp||0)+correct*5; let unlockedMsg=''; if(pct>=80){ const next=runtime.level+1; if(next<=10 && !STATE.progress.unlocked.includes(next)){ STATE.progress.unlocked.push(next); unlockedMsg=` Level ${next} unlocked!`; playLevelUp(); }} save();
 celebration.innerHTML=''; if(runtime.level<10){ const conf=document.createElement('div'); conf.className='mini-confetti'; conf.textContent='ðŸŽ‰'; celebration.appendChild(conf); setTimeout(()=>{celebration.innerHTML='';},2600); } else { const t=document.createElement('div'); t.className='trophy'; t.textContent='ðŸ†'; celebration.appendChild(t); setTimeout(()=>{celebration.innerHTML='';},5200); }
 document.getElementById('endTitle').textContent=`Level ${runtime.level} Complete`; endSummary.textContent=`Score: ${correct} / ${total} (${pct}%). XP: ${STATE.progress.xp}.${unlockedMsg}`; el('unlockText').textContent=unlockedMsg; showScreen('end'); }
el('advanceBtn').onclick=()=>{ const next=runtime.level+1; if(STATE.progress.scores[runtime.level] && STATE.progress.scores[runtime.level].pct>=80){ if(next<=10){ loadLevel(next); showScreen('game'); } else { loadLevel(10); } } else alert('You need at least 80% to advance.'); }
el('retryBtn').onclick=()=>{ STATE.pools[runtime.level]=shuffle(STATE.pools[runtime.level]); runtime.index=0; runtime.correct=0; save(); loadLevel(runtime.level); }
el('homeBtn').onclick=()=>{ updateLevelButtons(); showScreen('levelSelect'); }
startAtLevelBtn.onclick=()=>{ const lvl=Number(STATE.settings.selectedLevel)||1; if(!STATE.progress.unlocked.includes(lvl)){ alert('Level locked. Reach 80% on previous levels to unlock.'); return; } loadLevel(lvl); }
el('quitBtn').onclick=()=>homeBtn.onclick(); submitBtn.onclick=()=>checkAnswer(); el('openSettingsBtn').onclick=()=>showScreen('settings'); el('saveSettingsBtn').onclick=()=>{ STATE.settings.problemsPerRound=Math.min(100,Math.max(1,Number(problemsPerRoundInput.value)||100)); STATE.settings.enableSound=enableSoundInput.checked; STATE.settings.verboseSteps=verboseToggle.checked; save(); alert('Settings saved.'); showScreen('levelSelect'); }
updateLevelButtons(); scoreEl.textContent=`XP: ${STATE.progress.xp||0}`; showScreen('levelSelect');
